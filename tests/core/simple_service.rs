// Test for service implementation without macros
//
// This file shows how to manually implement what the service and action macros
// should generate, serving as a reference implementation.

use anyhow::{anyhow, Result};
use runar_common::types::ArcValueType;
use runar_node::services::{LifecycleContext, RequestContext, ServiceResponse};
use runar_node::AbstractService;
use std::collections::HashMap;
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use async_trait::async_trait;

// Define a simple math service
pub struct TestMathService {
    // Required fields for AbstractService
    name: String,
    path: String,
    version: String,
    description: String,
    network_id: Option<String>,
    
    // Service-specific fields
    counter: Arc<Mutex<i32>>,
}

impl TestMathService {
    // Constructor
    pub fn new(name: &str, path: &str) -> Self {
        Self {
            name: name.to_string(),
            path: path.to_string(),
            version: "1.0.0".to_string(),
            description: "Test math service".to_string(),
            network_id: None,
            counter: Arc::new(Mutex::new(0)),
        }
    }

    // Regular service methods (what would be marked with #[action])
    async fn add(&self, a_param: f64, b_param: f64, ctx: &RequestContext) -> Result<f64> {
        // Increment the counter
        let mut counter = self.counter.lock().unwrap();
        *counter += 1;

        // Log using the context
        ctx.debug(format!("Adding {} + {}", a_param, b_param));

        // Return the result
        Ok(a_param + b_param)
    }

    async fn subtract(&self, a_param: f64, b_param: f64, ctx: &RequestContext) -> Result<f64> {
        // Increment the counter
        let mut counter = self.counter.lock().unwrap();
        *counter += 1;

        // Log using the context
        ctx.debug(format!("Subtracting {} - {}", a_param, b_param));

        // Return the result
        Ok(a_param - b_param)
    }

    async fn multiply(&self, a_param: f64, b_param: f64, ctx: &RequestContext) -> Result<f64> {
        // Increment the counter
        let mut counter = self.counter.lock().unwrap();
        *counter += 1;

        // Log using the context
        ctx.debug(format!("Multiplying {} * {}", a_param, b_param));

        // Return the result
        Ok(a_param * b_param)
    }

    // What would be generated by #[action]
    async fn register_action_add(&self, context: &LifecycleContext) -> anyhow::Result<()> {
        context.info(format!("Registering '{}' action", "add"));
        
        // Create a clone of self that can be moved into the closure
        let self_clone = self.clone();
        
        // Create the action handler
        let handler = Arc::new(move |params_opt: Option<ArcValueType>, ctx: RequestContext| 
            -> Pin<Box<dyn Future<Output = Result<ServiceResponse, anyhow::Error>> + Send>> {
            let inner_self = self_clone.clone();
            
            Box::pin(async move {
                // Extract parameters from the map if available
                let mut params_value = match params_opt {
                    Some(p) => p,
                    None => {
                        ctx.error("No parameters provided".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("No parameters provided".to_string()),
                        });
                    }
                };
                
                let params_map = params_value.as_map_ref::<String, f64>()? ;
                  
                // Extract parameters by name
                let a_param = match params_map.get("a_param") {
                    Some(value) => {
                       value
                    },
                    None => {
                        ctx.error("Missing parameter a_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter a_param".to_string()),
                        });
                    }
                };
                
                let b_param = match params_map.get("b_param") {
                    Some(value) => {
                        value
                    },
                    None => {
                        ctx.error("Missing parameter b_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter b_param".to_string()),
                        });
                    }
                };

                // Call the actual method with the extracted parameters
                match inner_self.add(*a_param, *b_param, &ctx).await {
                    Ok(result) => {
                        // Convert the result to ArcValueType
                        let value_type = ArcValueType::new_primitive(result);
                        Ok(ServiceResponse {
                            status: 200,
                            data: Some(value_type),
                            error: None,
                        })
                    },
                    Err(err) => {
                        // Return an error response
                        ctx.error(format!("Action 'add' failed: {}", err));
                        Ok(ServiceResponse {
                            status: 500,
                            data: None,
                            error: Some(err.to_string()),
                        })
                    }
                }
            })
        });
        
        // Register the action handler
        context.register_action("add", handler).await
    }

    // What would be generated by #[action]
    async fn register_action_subtract(&self, context: &LifecycleContext) -> anyhow::Result<()> {
        context.info(format!("Registering '{}' action", "subtract"));
        
        // Create a clone of self that can be moved into the closure
        let self_clone = self.clone();
        
        // Create the action handler
        let handler = Arc::new(move |params_opt: Option<ArcValueType>, ctx: RequestContext| 
            -> Pin<Box<dyn Future<Output = Result<ServiceResponse, anyhow::Error>> + Send>> {
            let inner_self = self_clone.clone();
            
            Box::pin(async move {
                // Extract parameters from the map if available
                let mut params_value = match params_opt {
                    Some(p) => p,
                    None => {
                        ctx.error("No parameters provided".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("No parameters provided".to_string()),
                        });
                    }
                };
                
                let params_map = params_value.as_map_ref::<String, f64>()?;
                  
                // Extract parameters by name
                let a_param = match params_map.get("a_param") {
                    Some(value) => {
                       value
                    },
                    None => {
                        ctx.error("Missing parameter a_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter a_param".to_string()),
                        });
                    }
                };
                
                let b_param = match params_map.get("b_param") {
                    Some(value) => {
                        value
                    },
                    None => {
                        ctx.error("Missing parameter b_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter b_param".to_string()),
                        });
                    }
                };

                // Call the actual method with the extracted parameters
                match inner_self.subtract(*a_param, *b_param, &ctx).await {
                    Ok(result) => {
                        // Convert the result to ArcValueType
                        let value_type = ArcValueType::new_primitive(result);
                        Ok(ServiceResponse {
                            status: 200,
                            data: Some(value_type),
                            error: None,
                        })
                    },
                    Err(err) => {
                        // Return an error response
                        ctx.error(format!("Action 'subtract' failed: {}", err));
                        Ok(ServiceResponse {
                            status: 500,
                            data: None,
                            error: Some(err.to_string()),
                        })
                    }
                }
            })
        });
        
        // Register the action handler
        context.register_action("subtract", handler).await
    }

    // What would be generated by #[action("multiply_numbers")]
    async fn register_action_multiply(&self, context: &LifecycleContext) -> anyhow::Result<()> {
        context.info(format!("Registering '{}' action", "multiply_numbers"));
        
        // Create a clone of self that can be moved into the closure
        let self_clone = self.clone();
        
        // Create the action handler
        let handler = Arc::new(move |params_opt: Option<ArcValueType>, ctx: RequestContext| 
            -> Pin<Box<dyn Future<Output = Result<ServiceResponse, anyhow::Error>> + Send>> {
            let inner_self = self_clone.clone();
            
            Box::pin(async move {
                // Extract parameters from the map if available
                let mut params_value = match params_opt {
                    Some(p) => p,
                    None => {
                        ctx.error("No parameters provided".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("No parameters provided".to_string()),
                        });
                    }
                };
                
                let params_map = params_value.as_map_ref::<String, f64>()?;
                  
                // Extract parameters by name
                let a_param = match params_map.get("a_param") {
                    Some(value) => {
                       value
                    },
                    None => {
                        ctx.error("Missing parameter a_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter a_param".to_string()),
                        });
                    }
                };
                
                let b_param = match params_map.get("b_param") {
                    Some(value) => {
                        value
                    },
                    None => {
                        ctx.error("Missing parameter b_param".to_string());
                        return Ok(ServiceResponse {
                            status: 400,
                            data: None,
                            error: Some("Missing parameter b_param".to_string()),
                        });
                    }
                };

                // Call the actual method with the extracted parameters
                match inner_self.multiply(*a_param, *b_param, &ctx).await {
                    Ok(result) => {
                        // Convert the result to ArcValueType
                        let value_type = ArcValueType::new_primitive(result);
                        Ok(ServiceResponse {
                            status: 200,
                            data: Some(value_type),
                            error: None,
                        })
                    },
                    Err(err) => {
                        // Return an error response
                        ctx.error(format!("Action 'multiply_numbers' failed: {}", err));
                        Ok(ServiceResponse {
                            status: 500,
                            data: None,
                            error: Some(err.to_string()),
                        })
                    }
                }
            })
        });
        
        // Register the action handler
        context.register_action("multiply_numbers", handler).await
    }

    // What would be generated by service macro - register_actions
    async fn register_actions(&self, context: LifecycleContext) -> anyhow::Result<()> {
        // Register all the actions
        self.register_action_add(&context).await?;
        self.register_action_subtract(&context).await?;
        self.register_action_multiply(&context).await?;
        
        Ok(())
    }

    // Method to get the current counter value
    pub fn get_counter(&self) -> i32 {
        *self.counter.lock().unwrap()
    }
}

// AbstractService trait implementation (would be generated by service macro)
#[async_trait]
impl AbstractService for TestMathService {
    fn name(&self) -> &str {
        &self.name
    }

    fn version(&self) -> &str {
        &self.version
    }

    fn path(&self) -> &str {
        &self.path
    }

    fn description(&self) -> &str {
        &self.description
    }

    fn network_id(&self) -> Option<String> {
        self.network_id.clone()
    }

    async fn init(&self, context: LifecycleContext) -> anyhow::Result<()> {
        // Register all actions
        self.register_actions(context).await
    }

    async fn start(&self, _context: LifecycleContext) -> anyhow::Result<()> {
        // Default implementation does nothing
        Ok(())
    }

    async fn stop(&self, _context: LifecycleContext) -> anyhow::Result<()> {
        // Default implementation does nothing
        Ok(())
    }
}

// Implement Clone manually
impl Clone for TestMathService {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            path: self.path.clone(),
            version: self.version.clone(),
            description: self.description.clone(),
            network_id: self.network_id.clone(),
            counter: self.counter.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use runar_node::Node;
    use runar_node::NodeConfig;
    use tokio::time::timeout;
    use std::time::Duration;

    #[tokio::test]
    async fn test_math_service() {
        // Create a node with a test network ID
        let mut config = NodeConfig::new("test-node", "test_network");
        // Disable networking
        config.network_config = None;
        let mut node = Node::new(config).await.unwrap();

        // Create a test math service
        let service = TestMathService::new("Math", "math");

        // Add the service to the node
        node.add_service(service).await.unwrap();

        // Start the node to initialize all services
        node.start().await.unwrap();

        // Create parameters for the add action
        let mut map = std::collections::HashMap::new();
        map.insert("a_param".to_string(), 10.0);
        map.insert("b_param".to_string(), 5.0);
        let params = ArcValueType::new_map(map);

        // Call the add action
        let response = timeout(
            Duration::from_secs(5),
            node.request("math/add", params.clone()),
        )
        .await
        .unwrap();

        // Verify the response
        let response = response.unwrap();
        assert_eq!(response.status, 200);
        assert_eq!(
            response.data.unwrap().as_type::<f64>().unwrap(),
            15.0
        );

        // Make a request to the subtract action
        let response = timeout(
            Duration::from_secs(5),
            node.request("math/subtract", params.clone()),
        )
        .await
        .unwrap();

        // Verify the response
        let response = response.unwrap();
        assert_eq!(response.status, 200);
        assert_eq!(
            response.data.unwrap().as_type::<f64>().unwrap(),
            5.0
        );

        // Make a request to the multiply action (with custom name)
        let response = timeout(
            Duration::from_secs(5),
            node.request("math/multiply_numbers", params),
        )
        .await
        .unwrap();

        // Verify the response
        let response = response.unwrap();
        assert_eq!(response.status, 200);
        assert_eq!(
            response.data.unwrap().as_type::<f64>().unwrap(),
            50.0
        );
    }
}
